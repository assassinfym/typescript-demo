/**
 * 基础类型
 */
type 不可能 = never
type 空 = undefined
type 是 = true
type 否 = false


/**
 * 整数相关的定义
 */
type 零 = {
    是零吗: 是
}

type 加一<T extends 整数> = {
    前一个数: T
    是零吗: 否
}

type 整数 = 零 | { 前一个数: 整数; 是零吗: 否 }

type 减一<某个数 extends 整数> = 某个数 extends 加一<infer 前一个数>
    ? 前一个数
    : 不可能

type 一 = 加一<零>
type 二 = 加一<一>
type 三 = 加一<二>
type 四 = 加一<三>
type 五 = 加一<四>
type 六 = 加一<五>
type 七 = 加一<六>
type 八 = 加一<七>
type 九 = 加一<八>

/**
 * 偏序比较运算
 */
type 相等<
    第一个数 extends 整数,
    第二个数 extends 整数
    > = 第一个数 extends 零
    ? 第二个数 extends 零
        ? 是
        : 否
    : 第二个数 extends 零
        ? 否
        : 相等<减一<第一个数>, 减一<第二个数>>

type 大于<
    第一个数 extends 整数,
    第二个数 extends 整数
    > = 第一个数 extends 零
    ? 否
    : 第二个数 extends 零
        ? 是
        : 大于<减一<第一个数>, 减一<第二个数>>

type 小于<
    第一个数 extends 整数,
    第二个数 extends 整数
    > = 第一个数 extends 零
    ? 第二个数 extends 零
        ? 否
        : 是
    : 第二个数 extends 零
        ? 否
        : 小于<减一<第一个数>, 减一<第二个数>>

type 大于等于<
    第一个数 extends 整数,
    第二个数 extends 整数
    > = 是 extends 相等<第一个数, 第二个数> ? 是 : 大于<第一个数, 第二个数>

type 小于等于<
    第一个数 extends 整数,
    第二个数 extends 整数
    > = 是 extends 相等<第一个数, 第二个数> ? 是 : 小于<第一个数, 第二个数>

type 将两个整数从小到大排序<数组> = 数组 extends [
        infer 整数1,
        infer 整数2
    ]
    ? 整数1 extends 整数
        ? 整数2 extends 整数
            ? 是 extends 大于<整数1, 整数2>
                ? [整数2, 整数1]
                : [整数1, 整数2]
            : 不可能
        : 不可能
    : 不可能

/**
 * 开始测试
 */
type 相等0 = 相等<五, 六>
type 相等1 = 相等<八, 八>

type 减一0 = 相等<减一<四>, 二>
type 减一1 = 相等<减一<四>, 三>

type 加一0 = 相等<加一<四>, 五>
type 加一1 = 相等<加一<四>, 七>

type 小于0 = 小于<八, 三>
type 小于1 = 小于<二, 二>
type 小于2 = 小于<零, 一>
type 小于3 = 小于<二, 五>

type 大于0 = 大于<八, 三>
type 大于1 = 大于<二, 二>
type 大于2 = 大于<零, 一>
type 大于3 = 大于<五, 零>

type 小于等于0 = 小于等于<八, 三>
type 小于等于1 = 小于等于<二, 二>
type 小于等于2 = 小于等于<零, 一>
type 小于等于3 = 小于等于<二, 五>

type 大于等于0 = 大于等于<八, 三>
type 大于等于1 = 大于等于<二, 二>
type 大于等于2 = 大于等于<零, 一>
type 大于等于3 = 大于等于<五, 零>

type 排序0 = 将两个整数从小到大排序<[五, 三]>
type 排序1 = 将两个整数从小到大排序<[三, 五]>
type 排序2 = 将两个整数从小到大排序<[三, 三]>


/**
 * 棋子位置
 */
type 棋子横坐标 = 零 | 一 | 二 | 三 | 四 | 五 | 六 | 七 | 八
type 棋子纵坐标 = 零 | 一 | 二 | 三 | 四 | 五 | 六 | 七 | 八 | 九

type 最大横坐标 = 八
type 最大纵坐标 = 九

type 棋子坐标 = {
    横: 棋子横坐标
    纵: 棋子纵坐标
}

type 构造棋子坐标<横坐标, 纵坐标> = 横坐标 extends 棋子横坐标
    ? 纵坐标 extends 棋子纵坐标
        ? {
            横: 横坐标
            纵: 纵坐标
        }
        : 不可能
    : 不可能

type 相同位置<位置1, 位置2> = 位置1 extends 棋子坐标
    ? 位置2 extends 棋子坐标
        ? 相等<位置1['横'], 位置2['横']> & 相等<位置1['纵'], 位置2['纵']>
        : 不可能
    : 不可能

type 左邻位<位置> = 位置 extends 棋子坐标
    ? 大于<位置['横'], 零> & 构造棋子坐标<减一<位置['横']>, 位置['纵']>
    : 不可能

type 右邻位<位置> = 位置 extends 棋子坐标
    ? 小于<位置['横'], 最大横坐标> & 构造棋子坐标<加一<位置['横']>, 位置['纵']>
    : 不可能

type 上邻位<位置> = 位置 extends 棋子坐标
    ? 大于<位置['纵'], 零> & 构造棋子坐标<位置['横'], 减一<位置['纵']>>
    : 不可能

type 下邻位<位置> = 位置 extends 棋子坐标
    ? 小于<位置['纵'], 最大纵坐标> & 构造棋子坐标<位置['横'], 加一<位置['纵']>>
    : 不可能

/**
 * 开始测试
 */
type 相同位置0 = 相同位置<构造棋子坐标<零, 零>, 构造棋子坐标<零, 零>>
type 相同位置1 = 相同位置<构造棋子坐标<七, 八>, 构造棋子坐标<七, 八>>
type 相同位置2 = 相同位置<构造棋子坐标<二, 三>, 构造棋子坐标<二, 四>>
type 相同位置3 = 相同位置<构造棋子坐标<四, 五>, 构造棋子坐标<五, 五>>

type 左邻位0 = 相同位置<构造棋子坐标<零, 零>, 左邻位<构造棋子坐标<一, 零>>>
type 左邻位1 = 相同位置<构造棋子坐标<一, 零>, 左邻位<构造棋子坐标<零, 零>>>
type 左邻位2 = 相同位置<构造棋子坐标<二, 零>, 左邻位<构造棋子坐标<一, 零>>>
type 左邻位3 = 相同位置<构造棋子坐标<二, 零>, 左邻位<构造棋子坐标<一, 一>>>

type 右邻位0 = 相同位置<构造棋子坐标<零, 零>, 右邻位<构造棋子坐标<一, 零>>>
type 右邻位1 = 相同位置<构造棋子坐标<一, 零>, 右邻位<构造棋子坐标<零, 零>>>
type 右邻位2 = 相同位置<构造棋子坐标<二, 零>, 右邻位<构造棋子坐标<一, 零>>>
type 右邻位3 = 相同位置<构造棋子坐标<二, 零>, 右邻位<构造棋子坐标<一, 一>>>

type 上邻位0 = 相同位置<构造棋子坐标<零, 零>, 上邻位<构造棋子坐标<零, 一>>>
type 上邻位1 = 相同位置<构造棋子坐标<一, 零>, 上邻位<构造棋子坐标<零, 零>>>
type 上邻位2 = 相同位置<构造棋子坐标<二, 零>, 上邻位<构造棋子坐标<二, 一>>>
type 上邻位3 = 相同位置<构造棋子坐标<二, 零>, 上邻位<构造棋子坐标<一, 一>>>

type 下邻位0 = 相同位置<构造棋子坐标<零, 零>, 下邻位<构造棋子坐标<零, 一>>>
type 下邻位1 = 相同位置<构造棋子坐标<一, 零>, 下邻位<构造棋子坐标<零, 零>>>
type 下邻位2 = 相同位置<构造棋子坐标<二, 二>, 下邻位<构造棋子坐标<二, 一>>>
type 下邻位3 = 相同位置<构造棋子坐标<零, 二>, 下邻位<构造棋子坐标<零, 一>>>

/**
 * 棋子颜色
 */
type 黑色 = '黑'
type 红色 = '红'

type 棋子颜色 = 黑色 | 红色

/**
 * 棋子种类
 */
type 将 = '将'
type 士 = '士'
type 象 = '象'
type 马 = '马'
type 车 = '车'
type 炮 = '炮'
type 兵 = '兵'

type 棋子种类 = 将 | 士 | 象 | 马 | 车 | 炮 | 兵


/**
 * 棋子
 */
type 棋子 = {
    颜色: 棋子颜色
    种类: 棋子种类
}

type 构造棋子<某颜色, 某种类> = 某颜色 extends 棋子颜色
    ? 某种类 extends 棋子种类
        ? {
            颜色: 某颜色
            种类: 某种类
        }
        : 不可能
    : 不可能



/**
 * 棋局单元，描述棋盘上的一个棋位
 */
type 单元格内容参数 = 棋子 | 空

/**
 * 一
 */
type 棋局单元 = {
    内容: 单元格内容参数
    下一个: 棋局单元 | 空
}

type 构造棋局单元<内容参数, 下一个> = 内容参数 extends 单元格内容参数
    ? 下一个 extends 棋局单元 | 空
        ? {
            内容: 内容参数
            下一个: 下一个
        }
        : 不可能
    : 不可能

/**
 * 棋局行，描述棋局上的一行棋位
 */
type 行内容参数 = [
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数,
    单元格内容参数
]

type 棋局行 = {
    内容: 棋局单元 // 棋局单元形成的链表，指向第一个
    下一行: 棋局行 | 空
}

type 构造棋局行<内容参数, 下一行> = 内容参数 extends 行内容参数
    ? 下一行 extends 棋局行 | 空
        ? 内容参数 extends [
                infer 第零格,
                infer 第一格,
                infer 第二格,
                infer 第三格,
                infer 第四格,
                infer 第五格,
                infer 第六格,
                infer 第七格,
                infer 第八格
            ]
            ? {
                内容: 构造棋局单元<
                    第零格,
                    构造棋局单元<
                        第一格,
                        构造棋局单元<
                            第二格,
                            构造棋局单元<
                                第三格,
                                构造棋局单元<
                                    第四格,
                                    构造棋局单元<
                                        第五格,
                                        构造棋局单元<
                                            第六格,
                                            构造棋局单元<第七格, 构造棋局单元<第八格, 空>>
                                            >
                                        >
                                    >
                                >
                            >
                        >
                    >
                下一行: 下一行
            }
            : 不可能
        : 不可能
    : 不可能

/**
 * 棋局，描述整个棋盘上所有的棋位
 */
type 棋局内容参数 = [
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数,
    行内容参数
]

type 棋局 = {
    内容: 棋局行 // 棋局行形成的链表，指向第一个
}

type 构造棋局<内容 extends 棋局内容参数 = 棋局内容参数> = 内容 extends [
        infer 第零行,
        infer 第一行,
        infer 第二行,
        infer 第三行,
        infer 第四行,
        infer 第五行,
        infer 第六行,
        infer 第七行,
        infer 第八行,
        infer 第九行
    ]
    ? {
        内容: 构造棋局行<
            第零行,
            构造棋局行<
                第一行,
                构造棋局行<
                    第二行,
                    构造棋局行<
                        第三行,
                        构造棋局行<
                            第四行,
                            构造棋局行<
                                第五行,
                                构造棋局行<
                                    第六行,
                                    构造棋局行<
                                        第七行,
                                        构造棋局行<第八行, 构造棋局行<第九行, 空>>
                                        >
                                    >
                                >
                            >
                        >
                    >
                >
            >
    }
    : 不可能

/**
 * 下面这段是拷贝构造
 */
type 从内容构造棋局单元<
    内容参数 extends 单元格内容参数,
    下一个 extends 棋局单元 | 空
    > = {
    内容: 内容参数
    下一个: 下一个
}

type 从内容构造棋局行<单元链表 extends 棋局单元, 下一行 extends 棋局行 | 空> = {
    内容: 单元链表
    下一行: 下一行
}

type 从内容构造棋局<行链表 extends 棋局行> = {
    内容: 行链表
}

/**
 * 帮助函数
 */

/**
 * 在链表中获取指定行号的一行
 */
type 根据链表获取棋局指定行<
    行链表 extends 棋局行 | 空,
    行号 extends 棋子纵坐标
    > = 行链表 extends 棋局行
    ? 是 extends 相等<行号, 零>
        ? 行链表
        : 根据链表获取棋局指定行<行链表['下一行'], 减一<行号>>
    : 不可能

type 获取棋局指定行<
    某棋局 extends 棋局,
    行号 extends 棋子纵坐标
    > = 根据链表获取棋局指定行<某棋局['内容'], 行号>

/**
 * 在链表中获取指定列号的一个单元格
 */
type 根据链表获取棋局某行的指定单元格<
    单元链表 extends 棋局单元 | 空,
    列号 extends 棋子横坐标
    > = 单元链表 extends 棋局单元
    ? 是 extends 相等<列号, 零>
        ? 单元链表
        : 根据链表获取棋局某行的指定单元格<单元链表['下一个'], 减一<列号>>
    : 不可能

type 获取某行的指定单元格<
    某行 extends 棋局行,
    列号 extends 棋子横坐标
    > = 根据链表获取棋局某行的指定单元格<某行['内容'], 列号>

/**
 * 获取单元格内容
 */
type 获取某个单元内容<某单元 extends 棋局单元> = 某单元['内容']

/**
 * 获取棋局某位置的棋子
 */
type 获取棋局某位置的单元<
    某棋局 extends 棋局,
    某位置 extends 棋子坐标
    > = 获取棋局指定行<某棋局, 某位置['纵']> extends infer 某行 ? 某行 extends 棋局行 ? 获取某行的指定单元格<某行, 某位置['横']> : 不可能 : 不可能

type 获取棋局某位置的棋子<
    某棋局 extends 棋局,
    某位置 extends 棋子坐标
    > = 获取某个单元内容<获取棋局某位置的单元<某棋局, 某位置>>

/**
 * 将棋局中的指定行替换为新的棋局行，替换之后，返回新的棋局
 */
type 将棋局的某行替换为指定行<
    某棋局 extends 棋局,
    行号 extends 棋子纵坐标,
    新内容 extends 棋局单元,
    当前迭代行号 extends 整数
    > = 当前迭代行号 extends 棋子纵坐标
    ? 根据链表获取棋局指定行<
        某棋局['内容'],
        当前迭代行号
        > extends infer 原先的这行
        ? 原先的这行 extends 棋局行
            ? 是 extends 相等<行号, 当前迭代行号>
                ? 从内容构造棋局行<新内容, 原先的这行['下一行']> // 如果是要替换的这行，重新构造整个行，把原来的后续单元挂接过来就行了
                : 从内容构造棋局行<
                    原先的这行['内容'],
                    将棋局的某行替换为指定行<某棋局, 行号, 新内容, 加一<当前迭代行号>>
                    >
            : 不可能
        : 不可能
    : 空

/**
 * 将棋局中的指定行替换为新的棋局行，替换之后，返回新的棋局
 */
type 将棋局行的某单元替换为指定单元<
    某行 extends 棋局行,
    列号 extends 棋子横坐标,
    新内容 extends 单元格内容参数,
    当前迭代列号 extends 整数
    > = 当前迭代列号 extends 棋子横坐标
    ? 根据链表获取棋局某行的指定单元格<
        某行['内容'],
        当前迭代列号
        > extends infer 原先的这个单元
        ? 原先的这个单元 extends 棋局单元
            ? 是 extends 相等<列号, 当前迭代列号>
                ? 从内容构造棋局单元<新内容, 原先的这个单元['下一个']> // 如果是要替换的单元格，重新构造这个单元格，把原来的后续单元挂接过来就行了
                : 从内容构造棋局单元<
                    原先的这个单元['内容'],
                    将棋局行的某单元替换为指定单元<
                        某行,
                        列号,
                        新内容,
                        加一<当前迭代列号>
                        >
                    >
            : 不可能
        : 不可能
    : 空

/**
 * 替换棋子内容后，返回新的棋局
 */
type 将棋局某位置替换为指定棋子<
    某棋局 extends 棋局,
    某位置 extends 棋子坐标,
    某棋子或者空 extends 单元格内容参数
    > = 获取棋局某位置的单元<某棋局, 某位置> extends infer 原位置的单元
    ? 原位置的单元 extends 棋局单元
        ? 获取棋局指定行<某棋局, 某位置['纵']> extends infer 原有的行
            ? 原有的行 extends 棋局行
                ? 从内容构造棋局<
                    将棋局的某行替换为指定行<
                        某棋局,
                        某位置['纵'],
                        将棋局行的某单元替换为指定单元<
                            原有的行,
                            某位置['横'],
                            某棋子或者空,
                            零
                            >,
                        零
                        >
                    >
                : 不可能
            : 不可能
        : 不可能
    : 不可能

/**
 * 棋局相关的一些帮助函数
 */
type 该位置没有棋子<
    当前棋局 extends 棋局,
    某个位置 extends 棋子坐标
    > = 空 extends 获取棋局某位置的棋子<当前棋局, 某个位置> ? 是 : 否

type 该位置有棋子<
    当前棋局 extends 棋局,
    某个位置 extends 棋子坐标
    > = 获取棋局某位置的棋子<当前棋局, 某个位置> extends 棋子 ? 是 : 否

/**
 * 当需要寻找一条线上两点之间有几个棋子的时候，步骤是：
 * - 如果两点重合，返回零
 * - 否则沿着起点方向逐步向终点靠近，如果下一个点不是终点，并且有棋子，则累加一
 */
type 同一水平线上两个位置之间有几个棋子<
    纵坐标,
    横坐标1,
    横坐标2,
    当前棋局 extends 棋局,
    初始值 extends 整数
    > = 将两个整数从小到大排序<[横坐标1, 横坐标2]> extends [infer 小, infer 大]
    ? 小 extends 棋子横坐标
        ? 大 extends 棋子横坐标
            ? 是 extends 相等<小, 大>
                ? 初始值
                : 同一水平线上两个位置之间有几个棋子<
                    纵坐标,
                    加一<小>,
                    大,
                    当前棋局,
                    是 extends 相等<加一<小>, 大>
                        ? 初始值 // 下一个就是终点了，中间没有棋子可以累加了
                        : 是 extends 该位置有棋子<
                            当前棋局,
                            构造棋子坐标<加一<小>, 纵坐标>
                            >
                        ? 加一<初始值>
                        : 初始值
                    >
            : 不可能
        : 不可能
    : 不可能

type 同一竖直线上两个位置之间有几个棋子<
    横坐标,
    纵坐标1,
    纵坐标2,
    当前棋局 extends 棋局,
    初始值 extends 整数
    > = 将两个整数从小到大排序<[纵坐标1, 纵坐标2]> extends [infer 小, infer 大]
    ? 小 extends 棋子纵坐标
        ? 大 extends 棋子纵坐标
            ? 是 extends 相等<小, 大>
                ? 初始值
                : 是 extends 相等<加一<小>, 大>
                    ? 初始值
                    : 同一竖直线上两个位置之间有几个棋子<
                        横坐标,
                        加一<小>,
                        大,
                        当前棋局,
                        是 extends 该位置有棋子<当前棋局, 构造棋子坐标<横坐标, 加一<小>>>
                            ? 加一<初始值>
                            : 初始值
                        >
            : 不可能
        : 不可能
    : 不可能

type 在同一水平线上并且中间存在指定数量棋子<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局,
    数量 extends 整数
    > = 是 extends 相等<起始位置['纵'], 目标位置['纵']>
    ? 是 extends 相等<
            数量,
            同一水平线上两个位置之间有几个棋子<
                起始位置['纵'],
                起始位置['横'],
                目标位置['横'],
                当前棋局,
                零
                >
            >
        ? 是
        : 否
    : 不可能

type 在同一竖直线上并且中间存在指定数量棋子<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局,
    数量 extends 整数
    > = 是 extends 相等<起始位置['横'], 目标位置['横']>
    ? 是 extends 相等<
            数量,
            同一竖直线上两个位置之间有几个棋子<
                起始位置['横'],
                起始位置['纵'],
                目标位置['纵'],
                当前棋局,
                零
                >
            >
        ? 是
        : 否
    : 不可能

type 在一条直线上并且中间没有棋子<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 是 extends 在同一水平线上并且中间存在指定数量棋子<
        起始位置,
        目标位置,
        当前棋局,
        零
        >
    ? 是
    : 是 extends 在同一竖直线上并且中间存在指定数量棋子<
            起始位置,
            目标位置,
            当前棋局,
            零
            >
        ? 是
        : 否

type 在一条直线上并且中间只有一个棋子<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 是 extends 在同一水平线上并且中间存在指定数量棋子<
        起始位置,
        目标位置,
        当前棋局,
        一
        >
    ? 是
    : 是 extends 在同一竖直线上并且中间存在指定数量棋子<
            起始位置,
            目标位置,
            当前棋局,
            一
            >
        ? 是
        : 否

/**
 * 默认棋局
 */
type 默认棋局 = 构造棋局<
    [
        [
            构造棋子<黑色, 车>,
            构造棋子<黑色, 马>,
            构造棋子<黑色, 象>,
            构造棋子<黑色, 士>,
            构造棋子<黑色, 将>,
            构造棋子<黑色, 士>,
            构造棋子<黑色, 象>,
            构造棋子<黑色, 马>,
            构造棋子<黑色, 车>
        ],
        [空, 空, 空, 空, 空, 空, 空, 空, 空],
        [空, 构造棋子<黑色, 炮>, 空, 空, 空, 空, 空, 构造棋子<黑色, 炮>, 空],
        [
            构造棋子<黑色, 兵>,
            空,
            构造棋子<黑色, 兵>,
            空,
            构造棋子<黑色, 兵>,
            空,
            构造棋子<黑色, 兵>,
            空,
            构造棋子<黑色, 兵>
        ],
        [空, 空, 空, 空, 空, 空, 空, 空, 空],
        [空, 空, 空, 空, 空, 空, 空, 空, 空],
        [
            构造棋子<红色, 兵>,
            空,
            构造棋子<红色, 兵>,
            空,
            构造棋子<红色, 兵>,
            空,
            构造棋子<红色, 兵>,
            空,
            构造棋子<红色, 兵>
        ],
        [空, 构造棋子<红色, 炮>, 空, 空, 空, 空, 空, 构造棋子<红色, 炮>, 空],
        [空, 空, 空, 空, 空, 空, 空, 空, 空],
        [
            构造棋子<红色, 车>,
            构造棋子<红色, 马>,
            构造棋子<红色, 象>,
            构造棋子<红色, 士>,
            构造棋子<红色, 将>,
            构造棋子<红色, 士>,
            构造棋子<红色, 象>,
            构造棋子<红色, 马>,
            构造棋子<红色, 车>
        ]
    ]
    >

/**
 * 测试代码
 */
type 测试行0 = 获取棋局指定行<默认棋局, 零>
type 测试行1 = 获取棋局指定行<默认棋局, 二>

type 获取某行的棋子0 = 获取某行的指定单元格<测试行0, 零>
type 获取某行的棋子1 = 获取某行的指定单元格<测试行1, 一>

type 获取棋子1 = 获取棋局某位置的棋子<默认棋局, 构造棋子坐标<零, 零>>
type 获取棋子2 = 获取棋局某位置的棋子<默认棋局, 构造棋子坐标<一, 零>>
type 获取棋子3 = 获取棋局某位置的棋子<默认棋局, 构造棋子坐标<一, 二>>

type 在行中替换棋子0 = 将棋局行的某单元替换为指定单元<
    测试行0,
    一,
    构造棋子<红色, 车>,
    零
    >

type 在行中替换棋子1 = 将棋局行的某单元替换为指定单元<
    测试行0,
    五,
    构造棋子<红色, 车>,
    零
    >

type 在棋局中替换行0 = 将棋局的某行替换为指定行<
    默认棋局,
    零,
    测试行1['内容'],
    零
    >

type 在棋局中替换行1 = 将棋局的某行替换为指定行<
    默认棋局,
    一,
    测试行0['内容'],
    零
    >

type 在棋局替换棋子0 = 将棋局某位置替换为指定棋子<
    默认棋局,
    构造棋子坐标<零, 零>,
    构造棋子<红色, 车>
    >

type 在棋局替换棋子1 = 将棋局某位置替换为指定棋子<
    默认棋局,
    构造棋子坐标<零, 五>,
    构造棋子<红色, 车>
    >

type 在棋局替换棋子2 = 将棋局某位置替换为指定棋子<
    默认棋局,
    构造棋子坐标<五, 五>,
    构造棋子<红色, 车>
    >

type 坐标00到坐标04之间有几颗棋子 = 同一竖直线上两个位置之间有几个棋子<
    零,
    零,
    四,
    默认棋局,
    零
    >

// 这个实际上就是：开局的时候炮能不能吃对面的马
// tslint: disable-next-line
type 坐标12到坐标19之间有几颗棋子 = 同一竖直线上两个位置之间有几个棋子<
    一,
    二,
    九,
    默认棋局,
    零
    >

type 坐标00到坐标50之间有几颗棋子 = 同一水平线上两个位置之间有几个棋子<
    零,
    零,
    五,
    默认棋局,
    零
    >

type 计数0 = 在同一竖直线上并且中间存在指定数量棋子<
    构造棋子坐标<零, 零>,
    构造棋子坐标<零, 五>,
    默认棋局,
    一
    >

type 计数1 = 在同一竖直线上并且中间存在指定数量棋子<
    构造棋子坐标<零, 零>,
    构造棋子坐标<零, 一>,
    默认棋局,
    零
    >


type 渲染棋子<某个棋子> = 某个棋子 extends 棋子
    ? {
        红: {
            将: '帅'
            士: '仕'
            象: '相'
            马: '傌'
            车: '俥'
            炮: '炮'
            兵: '兵'
        }
        黑: {
            将: '将'
            士: '士'
            象: '象'
            马: '马'
            车: '车'
            炮: '砲'
            兵: '卒'
        }
    }[某个棋子['颜色']][某个棋子['种类']]
    : 不可能

type 渲染单元格<某单元格> = 某单元格 extends 棋子 ? 渲染棋子<某单元格> : '➕'

type 渲染单元链表<
    某单元 extends 棋局单元,
    初始渲染结果 extends string
    > = 某单元['下一个'] extends 棋局单元
    ? 渲染单元链表<
        某单元['下一个'],
        `${初始渲染结果} ${渲染单元格<某单元['内容']>}`
        >
    : `${初始渲染结果} ${渲染单元格<某单元['内容']>}`

type 数字键值对 = {
    零: 零
    一: 一
    二: 二
    三: 三
    四: 四
    五: 五
    六: 六
    七: 七
    八: 八
    九: 九
}

type 渲染指定行<某棋局 extends 棋局, 行号 extends 棋子纵坐标> = 获取棋局指定行<
    某棋局,
    行号
    > extends infer 某行
    ? 某行 extends 棋局行
        ? 渲染单元链表<某行['内容'], ''> extends infer 行渲染结果
            ? 行渲染结果 extends string
                ? `┠${行渲染结果} ┨`
                : 不可能
            : 不可能
        : 不可能
    : 不可能

type 渲染棋局<某个棋局 extends 棋局> = {
    [key in
        | '零'
        | '一'
        | '二'
        | '三'
        | '四'
        | '河'
        | '五'
        | '六'
        | '七'
        | '八'
        | '九']: key extends '河'
        ? '┠ ～ 楚 河 ～ ～ ～ 汉 界 ～ ┨'
        : 渲染指定行<
            某个棋局,
            key extends keyof 数字键值对 ? 数字键值对[key] : 不可能
            >
}

/**
 * 测试代码
 */
type 测试渲染棋子0 = 渲染单元格<构造棋子<红色, 将>>

type 测试渲染棋局的一行0 = 渲染单元链表<默认棋局['内容']['内容'], ''>
type 测试渲染棋局的一行1 = 渲染单元链表<
    默认棋局['内容']['下一行']['下一行']['内容'],
    ''
    >

type 测试渲染棋局0 = 渲染棋局<默认棋局>


type 黑将的可能位置 =
    | 构造棋子坐标<三, 零>
    | 构造棋子坐标<三, 一>
    | 构造棋子坐标<三, 二>
    | 构造棋子坐标<四, 零>
    | 构造棋子坐标<四, 一>
    | 构造棋子坐标<四, 二>
    | 构造棋子坐标<五, 零>
    | 构造棋子坐标<五, 一>
    | 构造棋子坐标<五, 二>

type 红将的可能位置 =
    | 构造棋子坐标<三, 七>
    | 构造棋子坐标<三, 八>
    | 构造棋子坐标<三, 九>
    | 构造棋子坐标<四, 七>
    | 构造棋子坐标<四, 八>
    | 构造棋子坐标<四, 九>
    | 构造棋子坐标<五, 七>
    | 构造棋子坐标<五, 八>
    | 构造棋子坐标<五, 九>

type 黑将可以放在这里吗<位置> = 位置 extends 黑将的可能位置 ? 是 : 否
type 红将可以放在这里吗<位置> = 位置 extends 红将的可能位置 ? 是 : 否

type 将可以放在这里吗<颜色, 位置> = 颜色 extends 红色
    ? 红将可以放在这里吗<位置>
    : 颜色 extends 黑色
        ? 黑将可以放在这里吗<位置>
        : 不可能

/**
 * 测试代码
 */
type 黑将00 = 将可以放在这里吗<黑色, 构造棋子坐标<零, 零>>
type 红将00 = 将可以放在这里吗<红色, 构造棋子坐标<零, 零>>
type 黑将31 = 将可以放在这里吗<黑色, 构造棋子坐标<三, 一>>
type 红将31 = 将可以放在这里吗<红色, 构造棋子坐标<三, 一>>
type 黑将47 = 将可以放在这里吗<黑色, 构造棋子坐标<四, 七>>
type 红将47 = 将可以放在这里吗<红色, 构造棋子坐标<四, 七>>


type 黑士的可能位置 =
    | 构造棋子坐标<三, 零>
    | 构造棋子坐标<三, 二>
    | 构造棋子坐标<四, 一>
    | 构造棋子坐标<五, 零>
    | 构造棋子坐标<五, 二>

type 红士的可能位置 =
    | 构造棋子坐标<三, 七>
    | 构造棋子坐标<三, 九>
    | 构造棋子坐标<四, 八>
    | 构造棋子坐标<五, 七>
    | 构造棋子坐标<五, 九>

type 黑士可以放在这里吗<位置> = 位置 extends 黑士的可能位置 ? 是 : 否
type 红士可以放在这里吗<位置> = 位置 extends 红士的可能位置 ? 是 : 否

type 士可以放在这里吗<颜色, 位置> = 颜色 extends 红色
    ? 红士可以放在这里吗<位置>
    : 颜色 extends 黑色
        ? 黑士可以放在这里吗<位置>
        : 不可能

/**
 * 测试代码
 */
type 黑士00 = 士可以放在这里吗<黑色, 构造棋子坐标<零, 零>>
type 红士00 = 士可以放在这里吗<红色, 构造棋子坐标<零, 零>>
type 黑士30 = 士可以放在这里吗<黑色, 构造棋子坐标<三, 零>>
type 红士30 = 士可以放在这里吗<红色, 构造棋子坐标<三, 零>>
type 黑士48 = 士可以放在这里吗<黑色, 构造棋子坐标<四, 八>>
type 红士48 = 士可以放在这里吗<红色, 构造棋子坐标<四, 八>>



type 黑象的可能位置 =
    | 构造棋子坐标<零, 二>
    | 构造棋子坐标<二, 零>
    | 构造棋子坐标<二, 四>
    | 构造棋子坐标<四, 二>
    | 构造棋子坐标<六, 零>
    | 构造棋子坐标<六, 四>
    | 构造棋子坐标<八, 二>

type 红象的可能位置 =
    | 构造棋子坐标<零, 七>
    | 构造棋子坐标<二, 五>
    | 构造棋子坐标<二, 九>
    | 构造棋子坐标<四, 七>
    | 构造棋子坐标<六, 五>
    | 构造棋子坐标<六, 九>
    | 构造棋子坐标<八, 七>

type 黑象可以放在这里吗<位置> = 位置 extends 黑象的可能位置 ? 是 : 否
type 红象可以放在这里吗<位置> = 位置 extends 红象的可能位置 ? 是 : 否

type 象可以放在这里吗<颜色, 位置> = 颜色 extends 红色
    ? 红象可以放在这里吗<位置>
    : 颜色 extends 黑色
        ? 黑象可以放在这里吗<位置>
        : 不可能

/**
 * 测试代码
 */
type 黑象00 = 象可以放在这里吗<黑色, 构造棋子坐标<零, 零>>
type 红象00 = 象可以放在这里吗<红色, 构造棋子坐标<零, 零>>
type 黑象60 = 象可以放在这里吗<黑色, 构造棋子坐标<六, 零>>
type 红象60 = 象可以放在这里吗<红色, 构造棋子坐标<六, 零>>
type 黑象47 = 象可以放在这里吗<黑色, 构造棋子坐标<四, 七>>
type 红象47 = 象可以放在这里吗<红色, 构造棋子坐标<四, 七>>



type 马可以放在这里吗<颜色, 位置> = 是


type 车可以放在这里吗<颜色, 位置> = 是


type 炮可以放在这里吗<颜色, 位置> = 是


type 黑兵可以放在这里吗<位置> = 位置 extends 棋子坐标
    ? 位置['纵'] extends 五 | 六 | 七 | 八 | 九 // 过了河
        ? 是
        : 位置['纵'] extends 三 | 四 // 没过河
            ? 位置['横'] extends 零 | 二 | 四 | 六 | 八 // 没过河的时候只能在这些列
                ? 是
                : 否
            : 不可能
    : 不可能

type 红兵可以放在这里吗<位置> = 位置 extends 棋子坐标
    ? 位置['纵'] extends 零 | 一 | 二 | 三 | 四 // 过了河
        ? 是
        : 位置['纵'] extends 五 | 六 // 没过河
            ? 位置['横'] extends 零 | 二 | 四 | 六 | 八 // 没过河的时候只能在这些列
                ? 是
                : 否
            : 否
    : 否

type 兵可以放在这里吗<颜色, 位置> = 颜色 extends 红色
    ? 红兵可以放在这里吗<位置>
    : 颜色 extends 黑色
        ? 黑兵可以放在这里吗<位置>
        : 不可能

/**
 * 测试代码
 */
type 黑兵00 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 零>>
type 黑兵01 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 一>>
type 黑兵02 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 二>>
type 黑兵03 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 三>>
type 黑兵04 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 四>>
type 黑兵05 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 五>>
type 黑兵06 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 六>>
type 黑兵07 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 七>>
type 黑兵08 = 兵可以放在这里吗<黑色, 构造棋子坐标<零, 八>>

type 红兵00 = 兵可以放在这里吗<红色, 构造棋子坐标<零, 一>>
type 红兵01 = 兵可以放在这里吗<红色, 构造棋子坐标<零, 二>>
type 红兵02 = 兵可以放在这里吗<红色, 构造棋子坐标<零, 三>>



type 棋子可以放在这里吗<某个棋子, 位置> = 某个棋子 extends 棋子
    ? 某个棋子['种类'] extends 将
        ? 将可以放在这里吗<某个棋子['颜色'], 位置>
        : 某个棋子['种类'] extends 士
            ? 士可以放在这里吗<某个棋子['颜色'], 位置>
            : 某个棋子['种类'] extends 象
                ? 象可以放在这里吗<某个棋子['颜色'], 位置>
                : 某个棋子['种类'] extends 马
                    ? 马可以放在这里吗<某个棋子['颜色'], 位置>
                    : 某个棋子['种类'] extends 车
                        ? 车可以放在这里吗<某个棋子['颜色'], 位置>
                        : 某个棋子['种类'] extends 炮
                            ? 炮可以放在这里吗<某个棋子['颜色'], 位置>
                            : 某个棋子['种类'] extends 兵
                                ? 兵可以放在这里吗<某个棋子['颜色'], 位置>
                                : 不可能
    : 不可能

/**
 * 将只能上下左右移动
 */
type 将可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标
    > = 是 extends 相同位置<左邻位<起始位置>, 目标位置>
    ? 是
    : 是 extends 相同位置<右邻位<起始位置>, 目标位置>
        ? 是
        : 是 extends 相同位置<上邻位<起始位置>, 目标位置>
            ? 是
            : 是 extends 相同位置<下邻位<起始位置>, 目标位置>
                ? 是
                : 否

/**
 * 士只能走一格斜线
 */
type 士可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标
    > = 是 extends 相同位置<左邻位<上邻位<起始位置>>, 目标位置>
    ? 是
    : 是 extends 相同位置<右邻位<上邻位<起始位置>>, 目标位置>
        ? 是
        : 是 extends 相同位置<右邻位<下邻位<起始位置>>, 目标位置>
            ? 是
            : 是 extends 相同位置<左邻位<下邻位<起始位置>>, 目标位置>
                ? 是
                : 否

/**
 * 象需要遍历四个斜向“田”的位置，并且判断象眼
 */
type 象可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 是 extends 相同位置<左邻位<左邻位<上邻位<上邻位<起始位置>>>>, 目标位置> // 左上
    ? 是 extends 该位置没有棋子<当前棋局, 左邻位<上邻位<起始位置>>> // 象眼
        ? 是
        : 否
    : 是 extends 相同位置<右邻位<右邻位<上邻位<上邻位<起始位置>>>>, 目标位置> // 右上
        ? 是 extends 该位置没有棋子<当前棋局, 右邻位<上邻位<起始位置>>> // 象眼
            ? 是
            : 否
        : 是 extends 相同位置<右邻位<右邻位<下邻位<下邻位<起始位置>>>>, 目标位置> // 右下
            ? 是 extends 该位置没有棋子<当前棋局, 右邻位<下邻位<起始位置>>> // 象眼
                ? 是
                : 否
            : 是 extends 相同位置<左邻位<左邻位<下邻位<下邻位<起始位置>>>>, 目标位置> // 左下
                ? 是 extends 该位置没有棋子<当前棋局, 左邻位<下邻位<起始位置>>> // 象眼
                    ? 是
                    : 否
                : 否

/**
 * 马需要遍历八个斜向“日”字的位置，并且判断马腿
 */
type 马可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 是 extends 相同位置<左邻位<左邻位<上邻位<起始位置>>>, 目标位置> // 上偏左
    ? 是 extends 该位置没有棋子<当前棋局, 左邻位<起始位置>> // 马腿在起始位置正左一位
        ? 是
        : 否
    : 是 extends 相同位置<左邻位<上邻位<上邻位<起始位置>>>, 目标位置> // 左偏上
        ? 是 extends 该位置没有棋子<当前棋局, 上邻位<起始位置>> // 马腿在起始位置正上一位
            ? 是
            : 否
        : 是 extends 相同位置<右邻位<上邻位<上邻位<起始位置>>>, 目标位置> // 右偏上
            ? 是 extends 该位置没有棋子<当前棋局, 上邻位<起始位置>> // 马腿在起始位置正上一位
                ? 是
                : 否
            : 是 extends 相同位置<右邻位<右邻位<上邻位<起始位置>>>, 目标位置> // 上偏右
                ? 是 extends 该位置没有棋子<当前棋局, 右邻位<起始位置>> // 马腿在起始位置正右一位
                    ? 是
                    : 否
                : 是 extends 相同位置<右邻位<右邻位<下邻位<起始位置>>>, 目标位置> // 下偏右
                    ? 是 extends 该位置没有棋子<当前棋局, 右邻位<起始位置>> // 马腿在起始位置正右一位
                        ? 是
                        : 否
                    : 是 extends 相同位置<右邻位<下邻位<下邻位<起始位置>>>, 目标位置> // 右偏下
                        ? 是 extends 该位置没有棋子<当前棋局, 下邻位<起始位置>> // 马腿在起始位置正下一位
                            ? 是
                            : 否
                        : 是 extends 相同位置<左邻位<下邻位<下邻位<起始位置>>>, 目标位置> // 左偏下
                            ? 是 extends 该位置没有棋子<当前棋局, 下邻位<起始位置>> // 马腿在起始位置正下一位
                                ? 是
                                : 否
                            : 是 extends 相同位置<左邻位<左邻位<下邻位<起始位置>>>, 目标位置> // 下偏左
                                ? 是 extends 该位置没有棋子<当前棋局, 左邻位<起始位置>> // 马腿在起始位置正左一位
                                    ? 是
                                    : 否
                                : 否

/**
 * 车，直线无阻挡
 */
type 车可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 在一条直线上并且中间没有棋子<起始位置, 目标位置, 当前棋局>

/**
 * 炮，直线无阻挡，或者直线上隔一个
 */
type 炮可以去那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 是 extends 在一条直线上并且中间没有棋子<起始位置, 目标位置, 当前棋局>
    ? 是
    : 是 extends 在一条直线上并且中间只有一个棋子<起始位置, 目标位置, 当前棋局>
        ? 是
        : 否

/**
 * 兵只能前进或者左右：
 * - 红兵的前进是向上
 * - 黑兵的前进是向下
 */
type 兵可以去那里吗<
    某个兵 extends 棋子,
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标
    > = 是 extends 相同位置<左邻位<起始位置>, 目标位置>
    ? 是
    : 是 extends 相同位置<右邻位<起始位置>, 目标位置>
        ? 是
        : 某个兵['颜色'] extends 红色
            ? 是 extends 相同位置<上邻位<起始位置>, 目标位置>
                ? 是
                : 否
            : 是 extends 相同位置<下邻位<起始位置>, 目标位置>
                ? 是
                : 否

type 具体的某个棋子可以从这里走到那里吗<
    某个棋子 extends 棋子,
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 某个棋子['种类'] extends 将
    ? 将可以去那里吗<起始位置, 目标位置>
    : 某个棋子['种类'] extends 士
        ? 士可以去那里吗<起始位置, 目标位置>
        : 某个棋子['种类'] extends 象
            ? 象可以去那里吗<起始位置, 目标位置, 当前棋局>
            : 某个棋子['种类'] extends 马
                ? 马可以去那里吗<起始位置, 目标位置, 当前棋局>
                : 某个棋子['种类'] extends 车
                    ? 车可以去那里吗<起始位置, 目标位置, 当前棋局>
                    : 某个棋子['种类'] extends 炮
                        ? 炮可以去那里吗<起始位置, 目标位置, 当前棋局>
                        : 兵可以去那里吗<某个棋子, 起始位置, 目标位置>

/**
 * 首先判断能否出现在目标位置
 * 再判断目标位置有没有己方棋子
 * 如果是敌方，或者是空的，就判断能不能走过去
 */
type 棋子可以从这里走到那里吗<
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标,
    当前棋局 extends 棋局
    > = 获取棋局某位置的棋子<当前棋局, 起始位置> extends infer 待移动的棋子
    ? 待移动的棋子 extends 棋子
        ? 是 extends 棋子可以放在这里吗<待移动的棋子, 目标位置>
            ? 获取棋局某位置的棋子<当前棋局, 目标位置> extends infer 目标位置棋子
                ? 目标位置棋子 extends 棋子
                    ? 目标位置棋子['颜色'] extends 待移动的棋子['颜色'] // 已经有棋子的话，颜色跟自己的一样是不能走的
                        ? 否
                        : 具体的某个棋子可以从这里走到那里吗<
                            待移动的棋子,
                            起始位置,
                            目标位置,
                            当前棋局
                            > // 吃对方
                    : 具体的某个棋子可以从这里走到那里吗<
                        待移动的棋子,
                        起始位置,
                        目标位置,
                        当前棋局
                        > // 走到空位置
                : 否
            : 不可能
        : 否
    : 不可能

type 走棋<
    当前棋局 extends 棋局,
    起始位置 extends 棋子坐标,
    目标位置 extends 棋子坐标
    > = 获取棋局某位置的棋子<当前棋局, 起始位置> extends infer 待移动的棋子
    ? 待移动的棋子 extends 棋子
        ? 是 extends 棋子可以从这里走到那里吗<起始位置, 目标位置, 当前棋局>
            ? 将棋局某位置替换为指定棋子<
                将棋局某位置替换为指定棋子<当前棋局, 起始位置, 空>,
                目标位置,
                待移动的棋子
                >
            : 不可能
        : 不可能
    : 不可能

// TODO 后面改造一个这种入口，来自引证的建议
// type 移动<动作> = 动作 extends infer `${红棋}${坐标}${方向}${数字}` ? ...
// 移动<"炮二平五">

/**
 * 测试代码
 */

type 将的移动0 = 将可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<四, 三>>
type 将的移动1 = 将可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<二, 三>>
type 将的移动2 = 将可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<三, 四>>
type 将的移动3 = 将可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<四, 四>>

type 士的移动0 = 士可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<四, 三>>
type 士的移动1 = 士可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<二, 四>>
type 士的移动2 = 士可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<三, 四>>
type 士的移动3 = 士可以去那里吗<构造棋子坐标<三, 三>, 构造棋子坐标<四, 四>>

type 象的移动0 = 象可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<四, 五>,
    默认棋局
    >
type 象的移动1 = 象可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 一>,
    默认棋局
    >
type 象的移动2 = 象可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<五, 五>,
    默认棋局
    >
type 象的移动3 = 象可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<一, 五>,
    默认棋局
    >

type 马的移动0 = 马可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<四, 五>,
    默认棋局
    >
type 马的移动1 = 马可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 一>,
    默认棋局
    >
type 马的移动2 = 马可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 四>,
    默认棋局
    >
type 马的移动3 = 马可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 二>,
    默认棋局
    >

type 车的移动0 = 车可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<三, 五>,
    默认棋局
    >
type 车的移动1 = 车可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<七, 三>,
    默认棋局
    >
type 车的移动2 = 车可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 四>,
    默认棋局
    >
type 车的移动3 = 车可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<四, 四>,
    默认棋局
    >

type 炮的移动0 = 炮可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<三, 五>,
    默认棋局
    >
type 炮的移动1 = 炮可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<六, 三>,
    默认棋局
    >
type 炮的移动2 = 炮可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 四>,
    默认棋局
    >
type 炮的移动3 = 炮可以去那里吗<
    构造棋子坐标<三, 三>,
    构造棋子坐标<四, 四>,
    默认棋局
    >

type 兵的移动0 = 兵可以去那里吗<
    构造棋子<红色, 兵>,
    构造棋子坐标<三, 三>,
    构造棋子坐标<三, 四>
    >
type 兵的移动1 = 兵可以去那里吗<
    构造棋子<红色, 兵>,
    构造棋子坐标<三, 三>,
    构造棋子坐标<三, 二>
    >
type 兵的移动2 = 兵可以去那里吗<
    构造棋子<黑色, 兵>,
    构造棋子坐标<三, 三>,
    构造棋子坐标<二, 三>
    >
type 兵的移动3 = 兵可以去那里吗<
    构造棋子<黑色, 兵>,
    构造棋子坐标<三, 三>,
    构造棋子坐标<四, 三>
    >

/**
 * 选中+移动的集成测试
 */
type 位置10的马能不能走到22 = 棋子可以从这里走到那里吗<
    构造棋子坐标<一, 零>,
    构造棋子坐标<二, 二>,
    默认棋局
    >

type 位置10的马能不能走到31 = 棋子可以从这里走到那里吗<
    构造棋子坐标<一, 零>,
    构造棋子坐标<三, 一>,
    默认棋局
    >

type 位置00的车能不能走到01 = 棋子可以从这里走到那里吗<
    构造棋子坐标<零, 零>,
    构造棋子坐标<零, 一>,
    默认棋局
    >

// tslint: disable-next-line
type 位置00的车能不能走到07 = 棋子可以从这里走到那里吗<
    构造棋子坐标<零, 零>,
    构造棋子坐标<零, 七>,
    默认棋局
    >

type 位置00的车能不能走到11 = 棋子可以从这里走到那里吗<
    构造棋子坐标<零, 零>,
    构造棋子坐标<一, 一>,
    默认棋局
    >

type 位置00的车能不能走到70 = 棋子可以从这里走到那里吗<
    构造棋子坐标<零, 零>,
    构造棋子坐标<七, 零>,
    默认棋局
    >

type 位置12的炮能不能走到22 = 棋子可以从这里走到那里吗<
    构造棋子坐标<一, 二>,
    构造棋子坐标<二, 二>,
    默认棋局
    >

type 位置12的炮能不能走到19 = 棋子可以从这里走到那里吗<
    构造棋子坐标<一, 二>,
    构造棋子坐标<一, 九>,
    默认棋局
    >

// 走棋的测试
type 移动棋子0 = 将棋局某位置替换为指定棋子<
    默认棋局,
    构造棋子坐标<零, 零>,
    构造棋子<红色, 车>
    >
type 走棋结果0 = 渲染棋局<移动棋子0>


// 当头炮
type 当头炮 = 走棋<默认棋局, 构造棋子坐标<一, 二>, 构造棋子坐标<四, 二>>
type 走棋结果1 = 渲染棋局<当头炮>

type 马来跳 = 走棋<当头炮, 构造棋子坐标<一, 九>, 构造棋子坐标<二, 七>>
type 走棋结果2 = 渲染棋局<马来跳>

type 开局吃马 = 走棋<默认棋局, 构造棋子坐标<一, 二>, 构造棋子坐标<一, 九>>
type 走棋结果3 = 渲染棋局<开局吃马>

//https://www.typescriptlang.org/play?ts=4.5.0-beta#code/PQKhCgAIUwv9UAQ9DePoaPUomOALgTwA4FNJBYOUHvlQX4DIBeSAO3wDd8AnLPQwLy8rIBXGgE3wAzAJZ0+rApED0Zl0xNu+CYUBkKl0EBDADYBnReHCgI0SIBdTQA6mgD7dAzoqAQt0BZ2oEk5NBhyTAb2lcA3lGlvA6CoAXNLgAL76roSABUqAAHIAPAAqkPgAHpj4-NqmZgB8Xj6AskrRgFRyZkHxPlL+Qcqh4WxZXB4APpCekIUlQeYA3L6BkKphSpCA84pxgAvmJUmp6XyZ5rnUk2bTaRmQMbGigsztxTk+APx7JT5BpGR1ktFcm27Zw4Axcrdx0Q8RkICQci+xj+-1gG21H6ff6SQApcj8AaDCIBbRR+YOhkEAwHI-GGIwDWij8kYjALpyP3RDwMYDQkEA8gqAeL1ACvWgGD4wAL8YB072cwwsgElvWI+QA03vtVrN5mYADScx5TFJrOZZHyLSBckUzdZuI7S4UrUW8yAKyCQY5SM4DXUc5U8+WKmqaoKs2JjWIynL80ZxA0lbKEj6Ack1AHFy7M1NqN4vMgu9htV63Mkq4PuD4o1Wr1ZqVsrFmWj2t1HstDv22TtVsdORd9UA8DqezncyN8gPxlVyv1mMPUCPVpOK3O+pua46myBBHVxltl9Um3VF9PWzPZh3K51XQgelnF72lxtZCt9pehzVSmT9i02u253LaruQNO7yv5yRFude6WLxPLoUJtXryCb1uQHf7PeTmMyILD0-7tOkCAGA6gAkckU5iAHNyBaAAxKrqAEnG5KxGYgAjflKqFvgA2j42y7OYACMFa4UwWQAEzgAAuoqBFvs+xzmKRtG1u20hvmmBF2gxDwsZhDGcWY+FUXGvECfxpFCUeFy6lJcZSUSRgwIAAPqANOagDStoAq9FMh8rIAAxcBaYJ2mizIsvh+lsuidoEkBYx6dQFpWlCdp-MMYxmfZbKOVmXznlE0R2e+bKbE5kAIsMMTuYFsTBd52JAUWAXDpZPnDEWkXDo8zmIkWjHUMObh2m8qXugAzFwGV2mFwwegFabJSC1XupFaaZZALluu6uXHp6BWQEVHVldQaaGeqvmQJe7qJe6V71dl01NeV82-FlxVzl1E2xL1-WFvNg3jUtrVVR1c61Uts2NXOzUHStx2dVws49YViIPXtD2xCN9xAYhAVgRBZjQXBiGxJhI2fBRiKIZFv1QbBCFIZhnyVeDwyIV10P-bDQMI3aYOEvJJKANMWgAK2oAsvKAHb+Wn1MTgBUVoACuqAOAWjSQC0NwtM8LTfC0QItBCLRwi0KItOiwzE4ArX4M0zLPM210uc5A3OhdL-PItLmItDiQGAADmrp04z1DCx82vi3rkAayLRMS9Q3iatTQQ0wzPii3bRPG7UwyACHmgAECcTDOxLrdrG1Kutvvb9OKsbIcuw7LHW5qkC2-H0dx07kCu5qYSyeQ0lZ8ygAwKuTsTk4RkDk6RUpF5HSfHKXldhyxFpF5hADk1NNxRdql83rfg5AABkUWN03ottx3ZOkc3w-I5nlzT0BgBnuoA3Qkk4XZPl2TteKmm5NdyPo195AXs+-TI7by3bfeafk-cZJOcfIAz8pLyva8byxw6n93dra7ruT94fFvH5sd+59R4T3PtnS4wxABQco-cmz9+xH03p6S+u97j7z-r7IB7d7Qr1AeDa+5xb71EANByMDV5cHJi-GMb8ya4M-q6QOaDvb-xwWfLBgCaFD3Pvg4gOdDAkhUhpSmkgLD5zJgFERBd0HH16vcO0UjNp2nuIiCRZNIoqNiPIpEVlvKaO0co0RXV1HyNaiCORTDfatShPo8me0jHmOPgCSqOj7HvScWNReJNxGiI0S4mR3kPE+KPrEaIijnSIg8Wo7x8iQmjTtAE+RfipwfA8YYqJLjWqyMgPElxMSlHhKXrYtJQSMn+MftEp6U5hgP08fpIpzC-F2mqYE5huSwlVKXpEyROTQmNLKb40JST6jVNSV04pPTIBNPKaNQZkhqmFNGcwkpvTl5TLeJUj40Can2Tqb7BpkBNnNN2RUxEmzOlk0OcfVpdoDkJIGScpeIzznGPGTc9JxyoEFNqQsixLy+lBJiWssaJCtnvh2dI8ZwKLkKL6m0j4wKzlQquZASFtzpmImBY8qFrU-h2hRW8mFMzCDAvmU8-pbVvJ4qCVtNp+NjDE0ADkZgAnIKEYQQAi3mMq4E3VlTdhiACK-Dl1Am68p5ebJlXB2XS35foPhdKiaAFnPRALKQKcuAjyj4gBrjU5eqtV9RACGMZy3VOrJCABsszlxqjWEEAGbxnLLUWsgIAOodOX2rtYAV0VOUupFR8YmCquDAWlpqlo+qWimpaNalojqWguv0LSmAxMlXEzyJqJlzsmU+AVc7BVbsPh-1iOMJldpxgKqlHmjl8CiappYoWxAkdM0xx8EmxlQQS31sgOmyAVafAZxvjPbt0aY2QAJoAAR1ACqyoAYUVAAw-4AeeNAAP8QTQAG26QJsMUAmJMlVjsADwWgBQxUAJ3agAh5RWNQBNLR2DSuJMYaI8aR2jsTZAHdQQN07v3T4IhxQ7ZXulieoY2bvZXtiI+gUyLihSn-W+B9e7mIxhfUUEO77j2KljpqO9t7wMtqg0EKDnbwFYf7UOwAMhFTtnYOxd0RcMrqVbhkD1BsKajA-uistGBQ+AY-R0dW7wMsbY3RpjrH-0cd49xzjjGaM8ZQ1REWg7cM3qQ0OsdkBgDAAHVewARvqAAQjGwgA-lMABYR47ADgxoARBUZTPpI2+yTcGv31EPhJv97HAO4eA+Bt8FGUMsRfZJ+BEmP2KhA-2ajcdiLSjcOuismp-NciCy20Ljxwtx0gKFz40W-M0B2CRDkAIEshaS7sDkYJ0uxcyylmEuXQtIiK-l6U6J10+AkscBDyGgiWbHdeGLHJAvBbjg10dTWYs3lyzFjrXXutKl691-rLbBveni218bB8f2NbG9N6UaWpsLdGwt8b2XhtrdW2t9bhXls7ZmzJzrHIStmKO9aCrdp2BTgOzF6+B37sLce4N57cdXuPce659DJHMOzz+72nDg6CMmCKPOyBgABI0AJDmNgyPQBcFTQdlHIC+ac1xzUqOhOQAxxWbHPhcfo-4wT9jePCdY9JxjyiQEh1Se3SZuTCm8OqY09p-ThnzOSEs9ZmDSOh3-vs1hHCZWWu4aIkLkjovktKhF4LyXHJPjS4y7LgECu8uy7BCr0LMINdC6RNr2X6I9dZZxLhyndaYtIcs7hgbAWVd9Z-Vb+bC5bcjft9b5rjxneDct277rcvPfje9479byv9sB9d0H6b2X-dbfD7d33WvQ8x7wz7g7J3o+3e9xyA3Z2rMcmN1dm7ce3sR-G696bZfusV43EH97Lbr5doIRAmVMAiGACN0wAm-GAFbrKQgB3o0ALixXslWQR3dt7zS5mNGeg+52TcGNw3sQ7T5DT6YtocA0UTDwxh-bu92OrTMGx24pIzB0zkBrs0-vaOrTRncPfZN+zwgW-Oe4b3+5uz5+sdX6GM3yAgA6PUAJVKgAv4rMToCnoKSQCAAU6lpoALRygA7cGABryjpnYLhoAO-KS6JucOwwgAnBaAB2xlpvAUOogQ7uji-kuHhh+jjsgZHGnC+FwM-ppsfoqFuEuBaCgaEoqHQbqDgXgXAQQUgbEHQc3K5rvFaCgYXo3kBPgYOoQdeOMNTu5hQVQUnFKFwZppIdIbIYOs3DurvKIaASSJAZprAQgXYIAOhKqBxQG6SqKhkh4wuGNgiBG614u+9B0+16x6FYZhkcusdYkAzh++o6jBb4FoZhbBLEzhnBuBqhPBg6th9hdgjhzhghxQwhcQZhYhPCECHw8BsRDhrGMhbmpBEmHhlBZa3hc+1A1h0ROR8ReRthWh26u8aRehxg8BYGSq2RRQY6O6uasmrhxaY69RbczRMANh5MMORM7RVRYxc2moGhMGFY4wFCZaShXAahfBGhBayCPc-Y-mthMYexr+MY2RdhuR66uaIu7amCuQjeAOWRUxZM4xMhchhRCxSxpB-8P